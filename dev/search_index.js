var documenterSearchIndex = {"docs":
[{"location":"references/","page":"References","title":"References","text":"AbsSmoothFrankWolfe.as_frank_wolfe\n","category":"page"},{"location":"references/#AbsSmoothFrankWolfe.as_frank_wolfe","page":"References","title":"AbsSmoothFrankWolfe.as_frank_wolfe","text":"as_frank_wolfe(f, grad!, lmo, x0; ...)\n\nSimplest form of the Frank-Wolfe algorithm. Returns a tuple (x, v, primal, dual_gap, traj_data) with:\n\nx final iterate\nv last vertex from the LMO\nprimal primal value f(x)\ndual_gap final Frank-Wolfe gap\ntraj_data vector of trajectory information.\n\n\n\n\n\n","category":"function"},{"location":"","page":"Home","title":"Home","text":"EditURL = \"https://github.com/ZIB-IOL/AbsSmoothFrankWolfe.jl/tree/main/README.md\"","category":"page"},{"location":"#AbsSmoothFrankWolfe.jl","page":"Home","title":"AbsSmoothFrankWolfe.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"(Image: CI) (Image: DOI)","category":"page"},{"location":"","page":"Home","title":"Home","text":"This package is a toolbox for Abs-Smooth Frank-Wolfe algorithm.","category":"page"},{"location":"#Overview","page":"Home","title":"Overview","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Abs-Smooth Frank-Wolfe algorithms are designed to solve optimization problems of the form minlimits_xin C  f(x) , for convex compact C and an abs-smooth function f.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The most recent release is available via the julia package manager, e.g., with","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg\nPkg.add(\"AbsSmoothFrankWolfe\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"or the main branch:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Pkg.add(url=\"https://github.com/ZIB-IOL/AbsSmoothFrankWolfe.jl\")","category":"page"},{"location":"#Getting-started","page":"Home","title":"Getting started","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Let's say we want to minimize the LASSO problem: frac12Ax - y_2^2 + rho x_1, subjected to simple box constraints.  This is what the code looks like:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using AbsSmoothFrankWolfe,FrankWolfe,LinearAlgebra,JuMP,HiGHS\n\njulia> import MathOptInterface\n\njulia> const MOI = MathOptInterface\n\njulia> n = 5 # choose lenght(x)\n\njulia> p = 3 # choose lenght(y)\n\njulia> rho = 0.5\n\njulia> A = rand(p,n) # randomly choose matrix A\n\njulia> y = rand(p) # randomly choose y\n\n#define the LASSO function\njulia>  function f(x)\n\t\n \treturn 0.5*(norm(A*x - y))^2 + rho*norm(x)\n\n end\n\n# evaluation point x_base\njulia> x_base = ones(n)*1.0\n\n# box constraints\njulia> lb_x = [-5 for in in x_base]\n\njulia> ub_x = [5 for in in x_base]\n\n# call the abs-linear form of f\njulia> abs_normal_form = AbsSmoothFrankWolfe.abs_linear(x_base,f)\n\n# gradient formula in terms of abs-linearization\njulia> alf_a = abs_normal_form.Y\n\njulia> alf_b = abs_normal_form.J \n\njulia> z = abs_normal_form.z \n\njulia> s = abs_normal_form.num_switches\n\njulia> sigma_z = AbsSmoothFrankWolfe.signature_vec(s,z)\n\njulia> function grad!(storage, x)\n    c = vcat(alf_a', alf_b'.* sigma_z)\n    @. storage = c\nend\n\n# define the model using JuMP with HiGHS as inner solver\njulia> o = Model(HiGHS.Optimizer)\n\njulia> MOI.set(o, MOI.Silent(), true)\n\njulia> @variable(o, lb_x[i] <= x[i=1:n] <= ub_x[i])\n\n# initialise dual gap\njulia> dualgap_asfw = Inf\n\n# abs-smooth lmo\njulia> lmo_as = AbsSmoothFrankWolfe.AbsSmoothLMO(o, x_base, f, n, s, lb_x, ub_x, dualgap_asfw)\n\n# define termination criteria using Frank-Wolfe 'callback' function\njulia> function make_termination_callback(state)\n return function callback(state,args...)\n  return state.lmo.dualgap_asfw[1] > 1e-2\n end\nend\n\njulia> callback = make_termination_callback(FrankWolfe.CallbackState)\n\n# call abs-smooth-frank-wolfe\njulia> x, v, primal, dual_gap, traj_data = AbsSmoothFrankWolfe.as_frank_wolfe(\n    f, \n    grad!, \n    lmo_as, \n    x_base;\n    gradient = ones(n+s),\n    line_search = FrankWolfe.FixedStep(1.0),\n    callback=callback,\n    verbose=true\n)\n","category":"page"},{"location":"","page":"Home","title":"Home","text":"Beyond those presented in the documentation, more test problems can be found in the examples folder.","category":"page"}]
}
